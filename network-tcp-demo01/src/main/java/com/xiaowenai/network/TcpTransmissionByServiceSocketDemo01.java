package com.xiaowenai.network;

import java.io.*;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;

/**
 * Description: 利用ServerSocket实现Tcp方式数据传输.启动多个套接字客户端不断向一个套接字服务端发送数据
 *
 * @author Shimmer
 * @version 1.0
 * @date 2020-03-31 17:58
 */
public class TcpTransmissionByServiceSocketDemo01 {
    public static void main(String[] args) {
        System.out.println("开始演示");
        System.out.println("启动Tcp服务端");
        new Thread(new TcpServerThread()).start();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("启动Tcp客户端自动生成干活线程类");
        new Thread(new TcpClientAutoGeneratedWordThread()).start();
    }
}

/**
 * Description: Tcp客户端自动生成干活线程类,开着不断发送客户端消息
 *
 * @author Shimmer
 * @version 1.0
 * @date 2020-03-31 17:58
 */
class TcpClientAutoGeneratedWordThread implements Runnable {

    public void run() {
        Socket clinetSocket = null;
        OutputStream outputStream = null;
        InputStream in = null;
        ByteArrayOutputStream baos = null;
        while (true) {
            try {

                clinetSocket = new Socket(InetAddress.getByName("localhost"), 8387);
                outputStream = clinetSocket.getOutputStream();
                //发送消息
                outputStream.write(("服务器你好(*´▽｀)ノノ收到了吱一声[" + System.currentTimeMillis() + "]").getBytes());
                clinetSocket.shutdownOutput();//传输完毕

                //接收服务器回应
                in = clinetSocket.getInputStream();

                baos = new ByteArrayOutputStream();
//                byte[] byteArr = new byte[1024];
                byte[] byteArr = new byte[clinetSocket.getReceiveBufferSize()];
                int len;
                while ((len = in.read(byteArr)) != -1) {
                    baos.write(byteArr, 0, len);
                }
                System.out.println("服务器回话:" + baos.toString());

                Thread.sleep(2000);

            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                closeResources(baos);
                closeResources(in);
                closeResources(outputStream);
                closeResources(clinetSocket);
            }
        }
    }

    /**
     * 关闭资源
     *
     * @param resources 可关闭的资源
     */
    private void closeResources(Closeable resources) {
        if (resources != null) {
            try {
                resources.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}

/**
 * Description: Tcp服务端线程类,开着不断接收客户端消息
 *
 * @author Shimmer
 * @version 1.0
 * @date 2020-03-31 17:58
 */
class TcpServerThread implements Runnable {

    public void run() {
        ServerSocket serverSocket = null;
        Socket socket = null;
        InputStream in = null;
        OutputStream out = null;
        try {
            serverSocket = new ServerSocket(8387);

            while (true) {
                //接收客户消息
                socket = serverSocket.accept();

                in = socket.getInputStream();

                ByteArrayOutputStream baos = new ByteArrayOutputStream();

//                byte[] byteArr = new byte[1024];
                byte[] byteArr = new byte[socket.getReceiveBufferSize()];
                int len;
                while ((len = in.read(byteArr)) != -1) {
                    baos.write(byteArr, 0, len);
                }
                System.out.println("客户端说:" + baos.toString());

                //收到了回吱一声
                out = socket.getOutputStream();
                out.write("吱!".getBytes());
                socket.shutdownOutput();

                closeResources(out);
                closeResources(in);
                closeResources(socket);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            closeResources(out);
            closeResources(in);
            closeResources(socket);
            closeResources(serverSocket);
        }
    }

    /**
     * 关闭资源
     *
     * @param resources 可关闭的资源
     */
    private void closeResources(Closeable resources) {
        if (resources != null) {
            try {
                resources.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}